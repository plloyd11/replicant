---
import BaseLayout from '../../layouts/BaseLayout.astro';
import ProductSale from '../../components/ProductSale.astro';
import CategoryFilter from '../../components/CategoryFilter.svelte';

interface Product {
    slug: string;
    id: string;
    title: string;
    description: string;
    price: number;
    images: { id: string; url: string }[];
    productType: string;
    productWeight: number;
    preOrder: boolean;
    fileGuid: string;
    createdAt: Date;
    sale?: boolean;
    sizes?: string;
    updatedAt?: string;
}

let products: Product[] = [];
let sizes: string[] = [];
let categories: string[] = [];

try {
    const result = await fetch(import.meta.env.PUBLIC_GRAPHCMS_API, {
        headers: {
            'Content-Type': 'application/json',
        },
        method: 'POST',
        body: JSON.stringify({
            query: `query{
                    products{
                        slug
                        id
                        sale
                        title
                        description
                        price
                        sizes
                        images {
                            id
                            url
                        }
                        productType
                        productWeight
                        preOrder
                        fileGuid
                        createdAt
                        updatedAt
                    }
                }`,
        }),
    });
    if (result.ok) {
        const resultJSON = await result.json();
        products = resultJSON.data.products;

        // turn createdAt into a date object
        products.forEach((product) => {
            product.createdAt = new Date(product.createdAt);
        });
        products = products.filter((product) => product.sale);
        // sort products by createdAt
        products.sort((a, b) => {
            if (a.productType === 'clothing' && b.productType !== 'clothing') return -1;
            if (b.productType === 'clothing' && a.productType !== 'clothing') return 1;
            return b.createdAt.getTime() - a.createdAt.getTime();
        });

        // Extract unique categories from product types
        const allCategories = new Set<string>();
        products.forEach((product) => {
            if (product.productType) {
                allCategories.add(product.productType);
            }
        });
        categories = Array.from(allCategories).sort();

        // Extract unique sizes from all products
        const allSizes = new Set<string>();

        products.forEach((product) => {
            if (product.sizes && typeof product.sizes === 'string') {
                // Split sizes by pipe and add each individually
                product.sizes.split('|').forEach((size) => {
                    // Clean up the size
                    const cleanSize = size
                        .trim()
                        .replace('Small', 'Small')
                        .replace('Medium', 'Medium')
                        .replace('Large', 'Large')
                        .replace('XXL', '2XL')
                        .replace('XXXL', '3XL')
                        .replace('triple_xl', '3XL')
                        .replace('double_xl', '2XL');

                    if (cleanSize) {
                        allSizes.add(cleanSize);
                    }
                });
            }
        });

        // If we found no sizes, use default clothing sizes
        if (allSizes.size === 0 && products.some((p) => p.productType === 'clothing')) {
            sizes = ['Small', 'Medium', 'Large', 'XL', '2XL', '3XL'];
        } else {
            sizes = Array.from(allSizes).sort((a, b) => {
                const sizeOrder = {
                    Small: 1,
                    Medium: 2,
                    Large: 3,
                    XL: 4,
                    '2XL': 5,
                    '3XL': 6,
                };

                return (sizeOrder[a] || 99) - (sizeOrder[b] || 99);
            });
        }
    } else {
        console.log('Error fetching data');
        throw new Error(`${result.status}: ${result.statusText}`);
    }
} catch (error) {
    console.error(error);
}
---

<BaseLayout
    title="Replicant | New Jersey Death Metal"
    desc="Site for the New Jersey based Death Metal band Replicant. Buy some shit!"
>
    <main>
        <div class="text-center bg-primary/5 py-8 sm:py-16 px-2">
            <h1 class="text-3xl sm:text-5xl font-bold tracking-tight text-replicant-100">
                Infinite Exhaustion Summer Tour Merch Blowout
            </h1>
            <p class="mx-auto mt-4 max-w-3xl text-lg text-replicant-300">
                We've returned from our European tour and are clearing out the remaining shirts.
            </p>
        </div>
        <CategoryFilter client:load categories={categories} sizes={sizes}>
            <div id="product-grid" class="grid grid-cols-1 gap-y-12 sm:grid-cols-2 sm:gap-x-10">
                {products.map((product) => <ProductSale product={product} />)}
            </div>
        </CategoryFilter>
    </main>
</BaseLayout>

<script is:inline>
    function initializeFilter() {
        const productGrid = document.getElementById('product-grid');
        if (!productGrid) {
            console.error('Product grid not found');
            return;
        }
        const products = Array.from(productGrid.children);

        document.addEventListener('filtersChange', (event) => {
            const { categories: selectedCategories, sizes: selectedSizes } = event.detail;

            products.forEach((product) => {
                const productType = product.dataset.productType;
                const productSizes = product.dataset.sizes || '';

                // If no filters are selected, show all products
                if (selectedCategories.length === 0 && selectedSizes.length === 0) {
                    product.style.display = '';
                    return;
                }

                let showProduct = false;

                // Check if product matches any selected category
                if (selectedCategories.length > 0) {
                    if (selectedCategories.includes(productType)) {
                        showProduct = true;
                    }
                }

                // Check if product matches any selected size
                if (selectedSizes.length > 0) {
                    const hasMatchingSize = selectedSizes.some((size) =>
                        productSizes.includes(size)
                    );

                    // If we have both category and size filters, product must match both
                    if (selectedCategories.length > 0) {
                        showProduct = showProduct && hasMatchingSize;
                    } else {
                        // If only size filters, just check size
                        showProduct = hasMatchingSize;
                    }
                }

                product.style.display = showProduct ? '' : 'none';
            });
        });
    }

    // Run the initialization function when the DOM is fully loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeFilter);
    } else {
        initializeFilter();
    }
</script>
