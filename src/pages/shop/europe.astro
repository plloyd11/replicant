---
import BaseLayout from '../../layouts/BaseLayout.astro';
import ProductSale from '../../components/ProductSale.astro';
import CategoryFilter from '../../components/CategoryFilter.svelte';
import { extractUniqueSizes } from '../../utils/sizes';

interface Product {
    slug: string;
    id: string;
    title: string;
    description: string;
    price: number;
    images: { id: string; url: string }[];
    productType: string;
    productWeight: number;
    preOrder: boolean;
    fileGuid: string;
    createdAt: Date;
    sale?: boolean;
    sizes?: string;
    updatedAt?: string;
}

let products: Product[] = [];
let sizes: string[] = [];
let categories: string[] = [];

try {
    const result = await fetch(import.meta.env.PUBLIC_GRAPHCMS_API, {
        headers: {
            'Content-Type': 'application/json',
        },
        method: 'POST',
        body: JSON.stringify({
            query: `query{
                    products{
                        slug
                        id
                        sale
                        title
                        description
                        price
                        sizes
                        images {
                            id
                            url
                        }
                        productType
                        productWeight
                        preOrder
                        fileGuid
                        createdAt
                        updatedAt
                    }
                }`,
        }),
    });
    if (result.ok) {
        const resultJSON = await result.json();
        products = resultJSON.data.products;

        // turn createdAt into a date object
        products.forEach((product) => {
            product.createdAt = new Date(product.createdAt);
        });
        products = products.filter((product) => product.sale);
        // sort products by createdAt
        products.sort((a, b) => {
            if (a.productType === 'clothing' && b.productType !== 'clothing') return -1;
            if (b.productType === 'clothing' && a.productType !== 'clothing') return 1;
            return b.createdAt.getTime() - a.createdAt.getTime();
        });

        // Extract unique categories from product types
        const allCategories = new Set<string>();
        products.forEach((product) => {
            if (product.productType) {
                allCategories.add(product.productType);
            }
        });
        categories = Array.from(allCategories).sort();

        sizes = extractUniqueSizes(products);
    } else {
        throw new Error(`${result.status}: ${result.statusText}`);
    }
} catch (error) {
    throw error;
}
---

<BaseLayout
    title="Replicant | New Jersey Death Metal"
    desc="Site for the New Jersey based Death Metal band Replicant. Buy some shit!"
>
    <main>
        <div class="px-2 py-8 text-center bg-primary/5 sm:py-16">
            <h1 class="text-3xl font-bold tracking-tight sm:text-5xl text-replicant-100">
                Infinite Exhaustion Summer Tour Merch Blowout
            </h1>
            <p class="mx-auto mt-4 max-w-3xl text-lg text-replicant-300">
                We've returned from our European tour and are clearing out the remaining shirts.
            </p>
        </div>
        <CategoryFilter client:load categories={categories} sizes={sizes}>
            <div id="product-grid" class="grid grid-cols-1 gap-y-12 sm:grid-cols-2 sm:gap-x-10">
                {products.map((product) => <ProductSale product={product} />)}
            </div>
        </CategoryFilter>
    </main>
</BaseLayout>

<script is:inline>
    function initializeFilter() {
        const productGrid = document.getElementById('product-grid');
        if (!productGrid) return;
        const products = Array.from(productGrid.children);

        document.addEventListener('filtersChange', (event) => {
            const { categories: selectedCategories, sizes: selectedSizes } = event.detail;

            products.forEach((product) => {
                const productType = product.dataset.productType;
                const productSizes = product.dataset.sizes || '';

                // If no filters are selected, show all products
                if (selectedCategories.length === 0 && selectedSizes.length === 0) {
                    product.style.display = '';
                    return;
                }

                let showProduct = false;

                // Check if product matches any selected category
                if (selectedCategories.length > 0) {
                    if (selectedCategories.includes(productType)) {
                        showProduct = true;
                    }
                }

                // Check if product matches any selected size
                if (selectedSizes.length > 0) {
                    const hasMatchingSize = selectedSizes.some((size) =>
                        productSizes.includes(size)
                    );

                    // If we have both category and size filters, product must match both
                    if (selectedCategories.length > 0) {
                        showProduct = showProduct && hasMatchingSize;
                    } else {
                        // If only size filters, just check size
                        showProduct = hasMatchingSize;
                    }
                }

                product.style.display = showProduct ? '' : 'none';
            });
        });
    }

    // Run the initialization function when the DOM is fully loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeFilter);
    } else {
        initializeFilter();
    }
</script>
